{
	"default template": {
		"prefix": "cpp",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"double eps = 1e-9;",
			"double pi = acos(-1);",
			"",
			"int fx[8] = {1, -1, 0, 0, 1, -1, -1, 1};",
			"int fy[8] = {0, 0, 1, -1, 1, -1, 1, -1};",
			"",
			"// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
			"",
			"int pop_cnt(int n) {return __builtin_popcount(n);}",
			"int clz(int n) {return __builtin_clz(n);}",
			"int ctz(int n) {return __builtin_ctz(n);}",
			"bool parity(int n) {return __builtin_parity(n);}",
			"",
			"void __print(int x) { cerr << x; }",
			"void __print(long x) { cerr << x; }",
			"void __print(long long x) { cerr << x; }",
			"void __print(unsigned x) { cerr << x; }",
			"void __print(unsigned long x) { cerr << x; }",
			"void __print(unsigned long long x) { cerr << x; }",
			"void __print(float x) { cerr << x; }",
			"void __print(double x) { cerr << x; }",
			"void __print(long double x) { cerr << x; }",
			"void __print(char x) { cerr << '\\'' << x << '\\''; }",
			"void __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }",
			"void __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }",
			"void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
			"",
			"template <typename T, typename V>",
			"void __print(const pair<T, V> &x)",
			"{",
			"    cerr << '{';",
			"    __print(x.first);",
			"    cerr << ',';",
			"    __print(x.second);",
			"    cerr << '}';",
			"}",
			"",
			"template <typename T>",
			"void __print(const T &x)",
			"{",
			"    int f = 0;",
			"    cerr << '{';",
			"    for (auto &i : x)",
			"        cerr << (f++ ? \",\" : \"\"), __print(i);",
			"    cerr << \"}\";",
			"}",
			"",
			"void _print() { cerr << \"]\\n\"; }",
			"template <typename T, typename... V>",
			"void _print(T t, V... v)",
			"{",
			"    __print(t);",
			"    if (sizeof...(v))",
			"        cerr << \", \";",
			"    _print(v...);",
			"}",
			"",
			"void RifatXia()",
			"{",
			"    #ifndef ONLINE_JUDGE",
			"        #define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
			"        freopen(\"in.txt\", \"r\", stdin);",
			"        freopen(\"out.txt\", \"w\", stderr);",
			"        freopen(\"out.txt\", \"a\", stdout);",
			"    #else",
			"        #define debug(x...)",
			"    #endif",
			"}",
			"",
			"#define fast_io ios_base::sync_with_stdio(false); cin.tie(0);",
			"#define ll long long",
			"#define ull unsigned long long",
			"#define en \"\\n\"",
			"#define ff first",
			"#define ss second",
			"#define sp(x) fixed << setprecision(x)",
			"#define runtime cout << \"Runtime: \" << clock() * 1.0 / CLOCKS_PER_SEC << en;",
			"#define SORT(v)  sort(v.begin(), v.end());",
			"#define RSORT(v) sort(v.begin(), v.end(), greater<int>())",
			"#define MIN(a, b) a < b ? a : b",
			"#define MAX(a, b) a > b ? a : b",
			"#define all(v) v.begin(), v.end()",
			"#define mem(a, b) memset(a, b, sizeof(a))",
			"#define get_bit(num, pos) {num & (1 << pos)}",
			"#define set_bit(num, pos) (num |= (1 << pos))",
			"#define reset_bit(num, pos) {num &= ~(1 << pos)}",
			"#define toggle_bit(num, pos) {num ^= (1 << pos)}",
			"#define valid(nx, ny, row, col) nx >= 0 && nx < row && ny >= 0 && ny < col",
			"#define pii pair <int, int>",
			"#define vi vector <int>",
			"#define vll vector <ll>",
			"#define inf int(2e9)",
			"#define mod int(1e9 + 7)",
			"",
			"int main(void)",
			"{",
			"    RifatXia();",
			"    fast_io",
			"",
			"    return 0;",
			"}"
		],
		"description": ""
	},
	"Test Cases": {
		"prefix": "tcp",
		"body": [
			"int t;\r",
			"cin >> t;\r",
			"for(int tc = 1; tc <= t; tc++)\r",
			"{\r",
			"\r",
			"}"
		],
		"description": "description for Test Cases"
	},
	"BigMod": {
		"prefix": "bigmod",
		"body": [
			"ll bigMod(ll a, ll b, ll c)\r",
			"{\r",
			"\tll rem = a % c, ans = 1 % c;\r",
			"\twhile(b > 0)\r",
			"\t{\r",
			"\t\tif(b % 2)\r",
			"\t\t\tans = (ans * rem) % c;\r",
			"\r",
			"\t\trem = (rem * rem) % c;\r",
			"\r",
			"\t\tb /= 2;\r",
			"\t}\r",
			"\treturn ans;\r",
			"}"
		],
		"description": "description for BigMod"
	},
	"BigPow": {
		"prefix": "bigpow",
		"body": [
			"ll bigPow(ll a, ll b)\r",
			"{\r",
			"\tll ans = 1;\r",
			"\twhile(b--)\r",
			"\t{\r",
			"\t\tans = ans * a;\r",
			"\t}\r",
			"\treturn ans;\r",
			"}"
		],
		"description": "description for BigPow"
	},
	"GCD": {
		"prefix": "gcd",
		"body": [
			"ll gcd(ll a, ll b)\r",
			"{\r",
			"\tif(b == 0)\r",
			"\t\treturn a;\r",
			"\telse\r",
			"\t\treturn gcd(b, a % b);\t\r",
			"}"
		],
		"description": "description for GCD"
	},
	"LCM": {
		"prefix": "lcm",
		"body": [
			"ll lcm(ll a, ll b)\r",
			"{\r",
			"\treturn (a/gcd(a, b)) * b;\r",
			"}"
		],
		"description": "description for LCM"
	},
	"Number of Divisors": {
		"prefix": "nod",
		"body": [
			"const int lim = \r",
			"\r",
			"int num[lim + 5] = {};\r",
			"\r",
			"void NOD()\r",
			"{\r",
			"\tfor(int i = 1; i <= lim; i++)\r",
			"\t{\r",
			"\t\tfor(int j = i; j <= lim; j += i)\r",
			"\t\t{\r",
			"\t\t\tnum[j]++;\r",
			"\t\t}\r",
			"\t}\r",
			"}"
		],
		"description": "Number of divisors"
	},
	"Prime Sieve": {
		"prefix": "primesieve",
		"body": [
			"const int lim = \r",
			"\r",
			"bool prime[lim + 10];\r",
			"vector <int> pNum;\r",
			"\r",
			"void sieve()\r",
			"{\r",
			"\tmem(prime, true);\r",
			"    prime[0] = prime[1] = false;\r",
			"\tfor(int i = 2; (ll)i * i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t{\r",
			"\t\t\tfor(int j = i * i; j <= lim; j += i)\r",
			"\t\t\t{\r",
			"\t\t\t\tprime[j] = false;\r",
			"\t\t\t}\r",
			"\t\t}\r",
			"\t}\r",
			"\r",
			"\tfor(int i = 2; i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t\tpNum.push_back(i);\r",
			"\t}\r",
			"}"
		],
		"description": "description for Prime Sieve"
	},
	"Sum of Divisors": {
		"prefix": "sod",
		"body": [
			"const int lim = \r",
			"\r",
			"int num[lim + 5];\r",
			"\r",
			"void SOD()\r",
			"{\r",
			"\tfor(int i = 1; i <= lim; i++)\r",
			"\t{\r",
			"\t\tfor(int j = i; j <= lim; j += i)\r",
			"\t\t{\r",
			"\t\t\tnum[j] += i;\r",
			"\t\t}\r",
			"\t}\r",
			"}"
		],
		"description": "description for Sum of Divisors"
	},
	"Primefactor O(n x n)": {
		"prefix": "primefactor",
		"body": [
			"const int lim = \r",
			"\r",
			"bool prime[lim + 10];\r",
			"vector <int> pNum, pf, times;\r",
			"\r",
			"void sieve()\r",
			"{\r",
			"\tmem(prime, true, sizeof(prime));\r",
			"    prime[0] = prime[1] = false;\r",
			"\tfor(int i = 2; (ll)i * i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t{\r",
			"\t\t\tfor(int j = i * i; j <= lim; j += i)\r",
			"\t\t\t{\r",
			"\t\t\t\tprime[j] = false;\r",
			"\t\t\t}\r",
			"\t\t}\r",
			"\t}\r",
			"\r",
			"\tfor(int i = 2; i <= lim; i++)\r",
			"\t{\r",
			"\t\tif(prime[i])\r",
			"\t\t\tpNum.push_back(i);\r",
			"\t}\r",
			"}\r",
			"\r",
			"void fact(ll n)\r",
			"{\r",
			"\tfor(int i = 0; i < pNum.size(); i++)\r",
			"\t{\r",
			"\t\tll p = pNum[i];\r",
			"\r",
			"\t\tif(p * p > n)\r",
			"\t\t\tbreak;\r",
			"\r",
			"\t\tint cnt = 0;\r",
			"\t\tif(n % p == 0)\r",
			"\t\t{\r",
			"\t\t\twhile(n % p == 0)\r",
			"\t\t\t{\r",
			"\t\t\t\tn /= p;\r",
			"\t\t\t\tcnt++;\r",
			"\t\t\t}\r",
			"\t\t\tpf.push_back(p);\r",
			"\t\t\ttimes.push_back(cnt);\r",
			"\t\t}\r",
			"\t}\r",
			"\tif(n > 1)\r",
			"\t{\r",
			"\t\tpf.push_back(n);\r",
			"\t\ttimes.push_back(1);\r",
			"\t}\r",
			"}"
		],
		"description": "description for Primefactor O(n x n)"
	},
	"DSU": {
		"prefix": "dsu",
		"body": [
			"const int lim = \r",
			"int parent[lim], len[lim];\r",
			"\r",
			"void make_set(int n)\r",
			"{\r",
			"    for(int i = 0; i <= n; i++)\r",
			"    {\r",
			"        parent[i] = i;\r",
			"        len[i] = 1;\r",
			"    }\r",
			"}\r",
			"\r",
			"int find_set(int v)\r",
			"{\r",
			"    if(parent[v] == v)\r",
			"        return v;\r",
			"\r",
			"    return parent[v] = find_set(parent[v]);\r",
			"}\r",
			"\r",
			"void union_set(int a, int b)\r",
			"{\r",
			"    a = find_set(a);\r",
			"    b = find_set(b);\r",
			"\r",
			"    if(a != b)\r",
			"    {\r",
			"        if(len[a] < len[b])\r",
			"            swap(a, b);\r",
			"\r",
			"        parent[b] = a;\r",
			"        len[a] += len[b];\r",
			"    }\r",
			"}"
		],
		"description": "description for DSU"
	},
	"trie_string": {
		"body": [
			"struct Trie\r",
			"{\r",
			"    struct node\r",
			"    {\r",
			"        int cnt, val;\r",
			"        bool ending;\r",
			"\r",
			"        node *next[lim];\r",
			"        node *child[2];\r",
			"\r",
			"        node()\r",
			"        {\r",
			"            cnt = 0, val = 0;\r",
			"            ending = false;\r",
			"            child[0] = NULL, child[1] = NULL;\r",
			"\r",
			"            for (int i = 0; i < lim; i++)\r",
			"                next[i] = NULL;\r",
			"        }\r",
			"    } * root;\r",
			"\r",
			"    void init()\r",
			"    {\r",
			"        root = new node();\r",
			"    }\r",
			"\r",
			"    void insert_string(string s)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 0; i < s.size(); i++)\r",
			"        {\r",
			"            int id = s[i] - 'a';\r",
			"            if (curr->next[id] == NULL)\r",
			"                curr->next[id] = new node();\r",
			"\r",
			"            curr = curr->next[id];\r",
			"        }\r",
			"\r",
			"        curr->cnt++;\r",
			"        curr->ending = true;\r",
			"    }\r",
			"\r",
			"    void insert_num(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            if (curr->child[id] == NULL)\r",
			"                curr->child[id] = new node();\r",
			"\r",
			"            curr = curr->child[id];\r",
			"            curr->cnt++;\r",
			"        }\r",
			"        curr->val = n;\r",
			"    }\r",
			"\r",
			"    void delete_num(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            curr = curr->child[id];\r",
			"            curr->cnt--;\r",
			"        }\r",
			"    }\r",
			"\r",
			"    bool search_string(string s)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 0; i < s.size(); i++)\r",
			"        {\r",
			"            int id = s[i] - 'a';\r",
			"\r",
			"            if (curr->next[id] == NULL)\r",
			"                return false;\r",
			"\r",
			"            curr = curr->next[id];\r",
			"        }\r",
			"        return (curr->ending);\r",
			"    }\r",
			"\r",
			"    bool search_num(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            if (curr->child[id] == NULL)\r",
			"                return false;\r",
			"\r",
			"            curr = curr->child[id];\r",
			"        }\r",
			"        return (curr->cnt);\r",
			"    }\r",
			"\r",
			"    int word_cnt(string s)\r",
			"    {\r",
			"        node *curr = root;\r",
			"        for (int i = 0; i < s.size(); i++)\r",
			"        {\r",
			"            int id = s[i] - 'a';\r",
			"            if (curr->next[id] == NULL)\r",
			"                return 0;\r",
			"\r",
			"            curr = curr->next[id];\r",
			"        }\r",
			"        return curr->cnt;\r",
			"    }\r",
			"\r",
			"    int max_array_xor(vector<int> v, int x)\r",
			"    {\r",
			"        int ans = 0;\r",
			"        for (int i = 0; i < v.size(); i++)\r",
			"        {\r",
			"            node *curr = root;\r",
			"\r",
			"            for (int j = 31; j >= 0; j--)\r",
			"            {\r",
			"                int id = get_bit(v[i], j);\r",
			"\r",
			"                if (curr->child[1 - id] != NULL && curr->child[1 - id]->cnt > 0)\r",
			"                    curr = curr->child[1 - id];\r",
			"                else if (curr->child[id] != NULL)\r",
			"                    curr = curr->child[id];\r",
			"\r",
			"                curr->cnt--;\r",
			"            }\r",
			"            int curr_max = (x ^ (curr->val));\r",
			"            ans = max(ans, curr_max);\r",
			"        }\r",
			"        return ans;\r",
			"    }\r",
			"\r",
			"    ll max_value_xor(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        ll ans = 0;\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            if (curr->child[1 - id] != NULL && curr->child[1 - id]->cnt > 0)\r",
			"            {\r",
			"                curr = curr->child[1 - id];\r",
			"                set_bit(ans, i);\r",
			"            }\r",
			"            else if (curr->child[id] != NULL && curr->child[id]->cnt > 0)\r",
			"            {\r",
			"                curr = curr->child[id];\r",
			"            }\r",
			"        }\r",
			"        return ans;\r",
			"    }\r",
			"};"
		]
	},
	"Trie Number": {
		"prefix": "trie_number",
		"body": [
			"struct Trie\r",
			"{\r",
			"    struct node\r",
			"    {\r",
			"        int cnt, val;\r",
			"        bool ending;\r",
			"\r",
			"        node *child[2];\r",
			"\r",
			"        node()\r",
			"        {\r",
			"            cnt = 0, val = 0;\r",
			"            ending = false;\r",
			"            child[0] = NULL, child[1] = NULL;\r",
			"        }\r",
			"    } * root;\r",
			"\r",
			"    void init()\r",
			"    {\r",
			"        root = new node();\r",
			"    }\r",
			"\r",
			"    void insert_num(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            if (curr->child[id] == NULL)\r",
			"                curr->child[id] = new node();\r",
			"\r",
			"            curr = curr->child[id];\r",
			"            curr->cnt++;\r",
			"        }\r",
			"        curr->val = n;\r",
			"    }\r",
			"\r",
			"    void delete_num(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            curr = curr->child[id];\r",
			"            curr->cnt--;\r",
			"        }\r",
			"    }\r",
			"\r",
			"    bool search_num(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            if (curr->child[id] == NULL)\r",
			"                return false;\r",
			"\r",
			"            curr = curr->child[id];\r",
			"        }\r",
			"        return (curr->cnt);\r",
			"    }\r",
			"\r",
			"    int max_array_xor(vector<int> v, int x)\r",
			"    {\r",
			"        int ans = 0;\r",
			"        for (int i = 0; i < v.size(); i++)\r",
			"        {\r",
			"            node *curr = root;\r",
			"\r",
			"            for (int j = 31; j >= 0; j--)\r",
			"            {\r",
			"                int id = get_bit(v[i], j);\r",
			"\r",
			"                if (curr->child[1 - id] != NULL && curr->child[1 - id]->cnt > 0)\r",
			"                    curr = curr->child[1 - id];\r",
			"                else if (curr->child[id] != NULL)\r",
			"                    curr = curr->child[id];\r",
			"\r",
			"                curr->cnt--;\r",
			"            }\r",
			"            int curr_max = (x ^ (curr->val));\r",
			"            ans = max(ans, curr_max);\r",
			"        }\r",
			"        return ans;\r",
			"    }\r",
			"\r",
			"    ll max_value_xor(int n)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        ll ans = 0;\r",
			"        for (int i = 31; i >= 0; i--)\r",
			"        {\r",
			"            int id = get_bit(n, i);\r",
			"\r",
			"            if (curr->child[1 - id] != NULL && curr->child[1 - id]->cnt > 0)\r",
			"            {\r",
			"                curr = curr->child[1 - id];\r",
			"                set_bit(ans, i);\r",
			"            }\r",
			"            else if (curr->child[id] != NULL && curr->child[id]->cnt > 0)\r",
			"            {\r",
			"                curr = curr->child[id];\r",
			"            }\r",
			"        }\r",
			"        return ans;\r",
			"    }\r",
			"};"
		],
		"description": ""
	},
	"Trie String": {
		"prefix": "trie_string",
		"body": [
			"const int lim = 26;\r",
			"\r",
			"struct Trie\r",
			"{\r",
			"    struct node\r",
			"    {\r",
			"        int cnt, val;\r",
			"        bool ending;\r",
			"\r",
			"        node *next[lim];\r",
			"        node *child[2];\r",
			"\r",
			"        node()\r",
			"        {\r",
			"            cnt = 0, val = 0;\r",
			"            ending = false;\r",
			"            child[0] = NULL, child[1] = NULL;\r",
			"\r",
			"            for (int i = 0; i < lim; i++)\r",
			"                next[i] = NULL;\r",
			"        }\r",
			"    } * root;\r",
			"\r",
			"    void init()\r",
			"    {\r",
			"        root = new node();\r",
			"    }\r",
			"\r",
			"    void insert_string(string s)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 0; i < s.size(); i++)\r",
			"        {\r",
			"            int id = s[i] - 'a';\r",
			"            if (curr->next[id] == NULL)\r",
			"                curr->next[id] = new node();\r",
			"\r",
			"            curr = curr->next[id];\r",
			"        }\r",
			"\r",
			"        curr->cnt++;\r",
			"        curr->ending = true;\r",
			"    }\r",
			"\r",
			"    bool search_string(string s)\r",
			"    {\r",
			"        node *curr = root;\r",
			"\r",
			"        for (int i = 0; i < s.size(); i++)\r",
			"        {\r",
			"            int id = s[i] - 'a';\r",
			"\r",
			"            if (curr->next[id] == NULL)\r",
			"                return false;\r",
			"\r",
			"            curr = curr->next[id];\r",
			"        }\r",
			"        return (curr->ending);\r",
			"    }\r",
			"\r",
			"    int word_cnt(string s)\r",
			"    {\r",
			"        node *curr = root;\r",
			"        for (int i = 0; i < s.size(); i++)\r",
			"        {\r",
			"            int id = s[i] - 'a';\r",
			"            if (curr->next[id] == NULL)\r",
			"                return 0;\r",
			"\r",
			"            curr = curr->next[id];\r",
			"        }\r",
			"        return curr->cnt;\r",
			"    }\r",
			"};"
		],
		"description": ""
	},
	"Palindrome": {
		"prefix": "palindrome",
		"body": [
			"bool isPalindrome(string s)\r",
			"{\r",
			"    string t = s;\r",
			"    reverse(all(s));\r",
			"\r",
			"    return (s == t);\r",
			"}"
		],
		"description": ""
	},
	"Primefactor O(log N)": {
		"prefix": "primefactor",
		"body": [
			"const int lim = 1e7;\r",
			"\r",
			"bool prime[lim + 10];\r",
			"vector <int> pNum;\r",
			"\r",
			"int spf[lim + 10];\r",
			"\r",
			"void sieve()\r",
			"{\r",
			"    spf[1] = 1;\r",
			"    for (int i = 2; i <= lim; i++)\r",
			"    {\r",
			"        spf[i] = i;\r",
			"    }\r",
			"\r",
			"    for (int i = 4; i <= lim; i += 2)\r",
			"    {\r",
			"        spf[i] = 2;\r",
			"    }\r",
			"\r",
			"    for (int i = 3; (ll)i * i <= lim; i++)\r",
			"    {\r",
			"        if (spf[i] == i)\r",
			"        {\r",
			"            for (int j = i * i; j <= lim; j += i)\r",
			"            {\r",
			"                if (spf[j] == j)\r",
			"                    spf[j] = i;\r",
			"            }\r",
			"        }\r",
			"    }\r",
			"}\r",
			"\r",
			"vector <int> fact(int n)\r",
			"{\r",
			"    vector<int> ans;\r",
			"    while (n != 1)\r",
			"    {\r",
			"        ans.push_back(spf[n]);\r",
			"        n /= spf[n];\r",
			"    }\r",
			"    return ans;\r",
			"}"
		],
		"description": ""
	},
	"Equal": {
		"prefix": "equal",
		"body": [
			"bool isEqual(double a, double b)\r",
			"{\r",
			"    return abs(a - b) <= eps;\r",
			"}"
		],
		"description": ""
	},
	"Greater": {
		"prefix": "greater",
		"body": [
			"bool isGreater(double a, double b)\r",
			"{\r",
			"    return a > b + eps;\r",
			"}"
		],
		"description": ""
	},
	"Long Division Quotient": {
		"prefix": "long_division",
		"body": [
			"string long_division(string number, int div)\r",
			"{\r",
			"    string ans = \"\";\r",
			"    int ind = 0;\r",
			"    int temp = number[ind] - '0';\r",
			"\r",
			"    while (temp < div)\r",
			"    {\r",
			"        temp = temp * 10 + number[++ind] - '0';\r",
			"    }\r",
			"\r",
			"    while (number.size() > ind)\r",
			"    {\r",
			"        ans += temp / div + '0';\r",
			"        temp = (temp % div) * 10 + number[++ind] - '0';\r",
			"    }\r",
			"\r",
			"    if (ans.size() == 0)\r",
			"        return \"0\";\r",
			"    else\r",
			"        return ans;\r",
			"}"
		]
	},
	"Long Division Remainder": {
		"prefix": "long_division",
		"body": [
			"int long_division(string number, int div)\r",
			"{\r",
			"    int ans = 0;\r",
			"\r",
			"    for (ll i = 0; i < number.size(); i++)\r",
			"    {\r",
			"        ans = (ans * 10 + number[i] - '0') % div;\r",
			"    }\r",
			"    return ans;\r",
			"}"
		],
		"description": ""
	},
	"NCR": {
		"prefix": "ncr",
		"body": [
			"ll gcd(ll a, ll b)\r",
			"{\r",
			"    if (b == 0)\r",
			"        return a;\r",
			"    else\r",
			"        return gcd(b, a % b);\r",
			"}\r",
			"\r",
			"ll ncr(int n, int r)\r",
			"{\r",
			"    if (n < r)\r",
			"        return 0;\r",
			"\r",
			"    if (r == 0)\r",
			"        return 1;\r",
			"\r",
			"    ll num = 1, den = 1;\r",
			"    r = min(r, n - r);\r",
			"\r",
			"    while (r > 0)\r",
			"    {\r",
			"        num *= n;\r",
			"        den *= r;\r",
			"\r",
			"        ll g = gcd(num, den);\r",
			"        num /= g;\r",
			"        den /= g;\r",
			"\r",
			"        n--;\r",
			"        r--;\r",
			"    }\r",
			"\r",
			"    return num;\r",
			"}"
		],
		"description": ""
	},
	"Pascal's Triangle": {
		"prefix": "pascal_triangle",
		"body": [
			"const int lim = 60;\r",
			"ll tri[lim + 5][lim + 5];\r",
			"\r",
			"void pascalTriangle()\r",
			"{\r",
			"    for (int i = 0; i < lim; i++)\r",
			"    {\r",
			"        for (int j = 0; j <= i; j++)\r",
			"        {\r",
			"            if (j == 0 || i == j)\r",
			"                tri[i][j] = 1;\r",
			"            else\r",
			"                tri[i][j] = tri[i - 1][j - 1] + tri[i - 1][j];\r",
			"        }\r",
			"    }\r",
			"}"
		],
		"description": ""
	},
	"Point Distance": {
		"prefix": "distance",
		"body": [
			"double point_distance(int ax, int ay, int bx, int by)\r",
			"{\r",
			"    double a = (ax - bx) * (ax - bx);\r",
			"    double b = (ay - by) * (ay - by);\r",
			"    double ans = sqrt(a + b);\r",
			"\r",
			"    return ans;\r",
			"}"
		],
		"description": ""
	},
	"Smaller": {
		"prefix": "smaller",
		"body": [
			"bool isSmaller(double a, double b)\r",
			"{\r",
			"    return a + eps < b;\r",
			"}"
		],
		"description": ""
	},
	"Decimal to Binary": {
		"prefix": "dec_to_bin",
		"body": [
			"string dec_to_bin(ll n)\r",
			"{\r",
			"    string ans = \"\";\r",
			"    while(n)\r",
			"    {\r",
			"        ans += to_string(n % 2);\r",
			"        n /= 2;\r",
			"    }\r",
			"    reverse(all(ans));\r",
			"\r",
			"    return ans;\r",
			"}"
		],
		"description": ""
	},
	"Segment Tree": {
		"prefix": "segment_tree",
		"body": [
			"const int lim = 1e5 + 10;",
			"ll num[lim], seg[4 * lim], lazy[4 * lim];",
			"",
			"void build(int i, int lo, int hi)",
			"{",
			"    if (lo == hi)",
			"    {",
			"        seg[i] = num[lo];",
			"        return;",
			"    }",
			"",
			"    int mid = (lo + hi) / 2;",
			"    int left = 2 * i + 1;",
			"    int right = 2 * i + 2;",
			"    ",
			"    build(left, lo, mid);",
			"    build(right, mid + 1, hi);",
			"",
			"    seg[i] = seg[left] + seg[right];",
			"}",
			"",
			"void update(int i, int lo, int hi, int l, int r, int x)",
			"{",
			"    int left = 2 * i + 1;",
			"    int right = 2 * i + 2;",
			"",
			"    if (hi < l || lo > r)",
			"        return;",
			"",
			"    if (lo >= l && hi <= r)",
			"    {",
			"        lazy[i] += x; ",
			"        return;",
			"    }",
			"",
			"    if (lazy[i] != 0)",
			"    {",
			"        lazy[left] += lazy[i];",
			"        lazy[right] += lazy[i];",
			"        lazy[i] = 0;",
			"    }",
			"",
			"    int mid = (lo + hi) / 2;",
			"    update(left, lo, mid, l, r, x);",
			"    update(right, mid + 1, hi, l, r, x);",
			"",
			"    seg[i] = seg[left] + lazy[left] * (mid - lo + 1) + seg[right] + lazy[right] * (hi - mid);",
			"}",
			"",
			"ll sum(int i, int lo, int hi, int l, int r)",
			"{",
			"    int left = 2 * i + 1;",
			"    int right = 2 * i + 2;",
			"    ",
			"    if (hi < l || lo > r)",
			"        return 0;",
			"",
			"    if (hi <= r && lo >= l)",
			"    {",
			"        return seg[i] + lazy[i] * (hi - lo + 1);",
			"    }",
			"",
			"    int mid = (lo + hi) / 2;",
			"    ll ans = sum(left, lo, mid, l, r) + sum(right, mid + 1, hi, l, r);",
			"    seg[i] = seg[left] + lazy[left] * (mid - lo + 1) + seg[right] + lazy[right] * (hi - mid);",
			"",
			"    return ans;",
			"}"
		],
		"description": "Segment Tree"
	},
	"Split String": {
		"prefix": "split_string",
		"body": [
			"void split_string(string s, char delimiter)\r",
			"{\r",
			"    string b;\r",
			"    stringstream a(s);\r",
			"    \r",
			"    while(getline(a, b, delimiter))\r",
			"    {\r",
			"        cout << b << en;\r",
			"    }\r",
			"}"
		],
		"description": ""
	},
	"pbds": {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>\r",
			"#include <ext/pb_ds/tree_policy.hpp>\r",
			"using namespace __gnu_pbds;\r",
			"\r",
			"typedef tree<\r",
			"    int, // the data type\r",
			"    null_type, // null_type for the set\r",
			"    less<int>, // the comparator. less_equal : ascending multimap, greater : descending\r",
			"    rb_tree_tag, // the tree structure would be red black tree\r",
			"    tree_order_statistics_node_update\r",
			"\r",
			"    // find_by_order(index) : finds the element using the index\r",
			"    // order_of_key(value) : finds the number of elements less than the value \r",
			"> ordered_set;"
		],
		"description": ""
	},
	"Decimal to Hexa": {
		"prefix": "dec_to_hex",
		"body": [
			"string dec_to_hex(ll n)\r",
			"{\r",
			"    stringstream ss;\r",
			"    ss << hex << n;\r",
			"    string ans(ss.str());\r",
			"    return ans;\r",
			"}"
		],
		"description": ""
	},
	"MST-Kruskal": {
		"prefix": "kruskal",
		"body": [
			"const int lim = ",
			"int parent[lim], len[lim];",
			"",
			"struct Edge",
			"{",
			"    int u, v, w;",
			"",
			"    Edge(int u, int v, int w) : u(u), v(v), w(w) {}",
			"    bool operator < (const Edge &q) const ",
			"    {",
			"        return w < q.w;",
			"    }",
			"};",
			"",
			"vector <Edge> edge;",
			"vector<pair<int, int>> graph[lim];",
			"",
			"void make_set(int n)",
			"{",
			"    edge.clear();",
			"    for(int i = 0; i <= n; i++)",
			"    {",
			"        parent[i] = i;",
			"        len[i] = 1;",
			"    }",
			"}",
			"",
			"int find_set(int v)",
			"{",
			"    if(parent[v] == v)",
			"        return v;",
			"",
			"    return parent[v] = find_set(parent[v]);",
			"}",
			"",
			"void union_set(int a, int b)",
			"{",
			"    a = find_set(a);",
			"    b = find_set(b);",
			"",
			"    if(a != b)",
			"    {",
			"        if(len[a] < len[b])",
			"            swap(a, b);",
			"",
			"        parent[b] = a;",
			"        len[a] += len[b];",
			"    }",
			"}",
			"",
			"ll kruskal()",
			"{",
			"    sort(edge.begin(), edge.end());",
			"    ll ans = 0;",
			"",
			"    for(auto x : edge)",
			"    {",
			"        int u = x.u, v = x.v, w = x.w;",
			"        if(find_set(u) != find_set(v))",
			"        {",
			"            ans += w;",
			"            union_set(u, v);",
			"            graph[u].push_back({v, w});",
			"            graph[v].push_back({u, w});",
			"        }",
			"    }",
			"    return ans;",
			"}"
		],
		"description": "MST-Kruskal"
	},
	"Euler's Totient": {
		"prefix": "totient",
		"body": [
			"const int lim = ",
			"int phi[lim];",
			"",
			"void eulers_totient() ",
			"{",
			"    phi[0] = 0;",
			"    phi[1] = 1;",
			"    for (int i = 2; i < lim; i++)",
			"        phi[i] = i - 1;",
			"",
			"    for (int i = 2; i < lim; i++)",
			"        for (int j = 2 * i; j < lim; j += i)",
			"              phi[j] -= phi[i];",
			"}"
		],
		"description": "Euler's Totient"
	},
	"LCA using binary lifting": {
	"prefix": "lca",
	"body": [
		"const int lim = 2e5 + 10, level = 19;",
		"vector <int> graph[lim];",
		"int parent[lim][level + 10], depth[lim], n, m;",
		"",
		"void dfs(int node, int par)",
		"{",
		"    parent[node][0] = par;",
		"    depth[node] = depth[par] + 1;",
		"",
		"    for(int i = 0; i < graph[node].size(); i++)",
		"    {",
		"        int c = graph[node][i];",
		"        if(c != par)",
		"            dfs(c, node);",
		"    }",
		"}",
		"",
		"void binary_lifting()",
		"{",
		"    for(int i = 1; i < level; i++)",
		"    {",
		"        for(int node = 1; node <= n; node++)",
		"        {",
		"            if(parent[ node ][ i - 1 ] != -1)",
		"                parent[node][i] = parent[ parent[node][i - 1] ][i - 1];",
		"        }",
		"    }",
		"}",
		"",
		"int lca(int u, int v)",
		"{",
		"    if(depth[v] < depth[u])",
		"        swap(u, v);",
		"",
		"    int k = depth[v] - depth[u];",
		"    for(int i = level; i >= 0; i--)",
		"    {",
		"        if(k & (1 << i))",
		"            v = parent[v][i];",
		"    }",
		"    if(u == v)",
		"        return u;",
		"",
		"    for(int i = level; i >= 0; i--)",
		"    {",
		"        if(parent[u][i] != parent[v][i])",
		"        {",
		"            u = parent[u][i];",
		"            v = parent[v][i];",
		"        }",
		"    }",
		"    return parent[u][0];",
		"}"
	],
	"description": "LCA using binary lifting"
	}
}