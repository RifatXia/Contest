{
    "default template": {
        "prefix": "cpp",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "",
            "double eps = 1e-9;",
            "double pi = acos(-1);",
            "",
            "int fx[8] = {1, -1, 0, 0, 1, -1, -1, 1};",
            "int fy[8] = {0, 0, 1, -1, 1, -1, 1, -1};",
            "",
            "// mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());",
            "",
            "int pop_cnt(int n) {return __builtin_popcount(n);}",
            "int clz(int n) {return __builtin_clz(n);}",
            "int ctz(int n) {return __builtin_ctz(n);}",
            "bool parity(int n) {return __builtin_parity(n);}",
            "",
            "void __print(int x) { cerr << x; }",
            "void __print(long x) { cerr << x; }",
            "void __print(long long x) { cerr << x; }",
            "void __print(unsigned x) { cerr << x; }",
            "void __print(unsigned long x) { cerr << x; }",
            "void __print(unsigned long long x) { cerr << x; }",
            "void __print(float x) { cerr << x; }",
            "void __print(double x) { cerr << x; }",
            "void __print(long double x) { cerr << x; }",
            "void __print(char x) { cerr << '\\'\\'' << x << '\\'\\''; }",
            "void __print(const char *x) { cerr << '\\\"' << x << '\\\"'; }",
            "void __print(const string &x) { cerr << '\\\"' << x << '\\\"'; }",
            "void __print(bool x) { cerr << (x ? \"true\" : \"false\"); }",
            "",
            "template <typename T, typename V>",
            "void __print(const pair<T, V> &x)",
            "{",
            "    cerr << '{';",
            "    __print(x.first);",
            "    cerr << ',';",
            "    __print(x.second);",
            "    cerr << '}';",
            "}",
            "",
            "template <typename T>",
            "void __print(const T &x)",
            "{",
            "    int f = 0;",
            "    cerr << '{';",
            "    for (auto &i : x)",
            "        cerr << (f++ ? \",\" : \"\") << i;",
            "    cerr << '}';",
            "}",
            "",
            "void _print() { cerr << \"]\\n\"; }",
            "",
            "template <typename T, typename... V>",
            "void _print(T t, V... v)",
            "{",
            "    __print(t);",
            "    if (sizeof...(v))",
            "        cerr << \", \";",
            "    _print(v...);",
            "}",
            "",
            "void RifatXia()",
            "{",
            "    #ifndef ONLINE_JUDGE",
            "        #define debug(x...) cerr << \"[\" << #x << \"] = [\"; _print(x)",
            "        freopen(\"in.txt\", \"r\", stdin);",
            "        freopen(\"out.txt\", \"w\", stderr);",
            "        freopen(\"out.txt\", \"a\", stdout);",
            "    #else",
            "        #define debug(x...)",
            "    #endif",
            "}",
            "",
            "#define fast_io ios_base::sync_with_stdio(false); cin.tie(0);",
            "#define ll long long",
            "#define ull unsigned long long",
            "#define en \"\\n\"",
            "#define ff first",
            "#define ss second",
            "#define sp(x) fixed << setprecision(x)",
            "#define runtime cout << \"Runtime: \" << clock() * 1.0 / CLOCKS_PER_SEC << en;",
            "#define SORT(v)  sort(v.begin(), v.end());",
            "#define RSORT(v) sort(v.begin(), v.end(), greater<int>())",
            "#define MIN(a, b) a < b ? a : b",
            "#define MAX(a, b) a > b ? a : b",
            "#define all(v) v.begin(), v.end()",
            "#define mem(a, b) memset(a, b, sizeof(a))",
            "#define get_bit(num, pos) {num & (1 << pos)}",
            "#define set_bit(num, pos) (num |= (1 << pos))",
            "#define reset_bit(num, pos) {num &= ~(1 << pos)}",
            "#define toggle_bit(num, pos) {num ^= (1 << pos)}",
            "#define valid(nx, ny, row, col) nx >= 0 && nx < row && ny >= 0 && ny < col",
            "#define pii pair <int, int>",
            "#define vi vector <int>",
            "#define vll vector <ll>",
            "#define inf int(2e9)",
            "#define mod int(1e9 + 7)",
            "",
            "int main(void)",
            "{",
            "    RifatXia();",
            "    fast_io",
            "",
            "    return 0;",
            "}"
        ],
        "description": ""
    },
    "Test Cases": {
    "prefix": "tcp",
    "body": [
        "int t;",
        "cin >> t;",
        "for(int tc = 1; tc <= t; tc++)",
        "{",
        "",
        "}"
    ],
    "description": "description for Test Cases"
    },
    "BigMod": {
    "prefix": "bigmod",
    "body": [
        "ll bigMod(ll a, ll b, ll c)",
        "{",
        "    ll rem = a % c, ans = 1 % c;",
        "    while(b > 0)",
        "    {",
        "        if(b % 2)",
        "            ans = (ans * rem) % c;",
        "",
        "        rem = (rem * rem) % c;",
        "        b /= 2;",
        "    }",
        "    return ans;",
        "}"
    ],
    "description": "description for BigMod"
    },
    "BigPow": {
    "prefix": "bigpow",
    "body": [
        "ll bigPow(ll a, ll b)",
        "{",
        "    ll ans = 1;",
        "    while(b--)",
        "    {",
        "        ans = ans * a;",
        "    }",
        "    return ans;",
        "}"
    ],
    "description": "description for BigPow"
    },  
    "GCD": {
    "prefix": "gcd",
    "body": [
        "ll gcd(ll a, ll b)",
        "{",
        "    if(b == 0)",
        "        return a;",
        "    else",
        "        return gcd(b, a % b);",
        "}"
    ],
    "description": "description for GCD"
    },
    "LCM": {
    "prefix": "lcm",
    "body": [
        "ll lcm(ll a, ll b)",
        "{",
        "    return (a/gcd(a, b)) * b;",
        "}"
    ],
    "description": "description for LCM"
    },
    "Number of Divisors": {
    "prefix": "nod",
    "body": [
        "const int lim = ",
        "",
        "int num[lim + 5] = {};",
        "",
        "void NOD()",
        "{",
        "    for(int i = 1; i <= lim; i++)",
        "    {",
        "        for(int j = i; j <= lim; j += i)",
        "        {",
        "            num[j]++;",
        "        }",
        "    }",
        "}"
    ],
    "description": "Number of divisors"
    },
    "Prime Sieve": {
    "prefix": "primesieve",
    "body": [
        "const int lim = ",
        "",
        "bool prime[lim + 10];",
        "vector <int> pNum;",
        "",
        "void sieve()",
        "{",
        "    mem(prime, true);",
        "    prime[0] = prime[1] = false;",
        "    for(int i = 2; (ll)i * i <= lim; i++)",
        "    {",
        "        if(prime[i])",
        "        {",
        "            for(int j = i * i; j <= lim; j += i)",
        "            {",
        "                prime[j] = false;",
        "            }",
        "        }",
        "    }",
        "",
        "    for(int i = 2; i <= lim; i++)",
        "    {",
        "        if(prime[i])",
        "            pNum.push_back(i);",
        "    }",
        "}"
    ],
    "description": "description for Prime Sieve"
    },
    "Sum of Divisors": {
    "prefix": "sod",
    "body": [
        "const int lim = ",
        "",
        "int num[lim + 5];",
        "",
        "void SOD()",
        "{",
        "    for(int i = 1; i <= lim; i++)",
        "    {",
        "        for(int j = i; j <= lim; j += i)",
        "        {",
        "            num[j] += i;",
        "        }",
        "    }",
        "}"
    ],
    "description": "description for Sum of Divisors"
    },
    "Primefactor O(n x n)": {
    "prefix": "primefactor",
    "body": [
        "const int lim = $1;",
        "bool prime[lim + 10];",
        "vector<int> pNum, pf, times;",
        "",
        "void sieve() {",
        "    mem(prime, true, sizeof(prime));",
        "    prime[0] = prime[1] = false;",
        "    for(int i = 2; (ll)i * i <= lim; i++) {",
        "        if(prime[i]) {",
        "            for(int j = i * i; j <= lim; j += i) {",
        "                prime[j] = false;",
        "            }",
        "        }",
        "    }",
        "    for(int i = 2; i <= lim; i++) {",
        "        if(prime[i]) {",
        "            pNum.push_back(i);",
        "        }",
        "    }",
        "}",
        "",
        "void fact(ll n) {",
        "    for(int i = 0; i < pNum.size(); i++) {",
        "        ll p = pNum[i];",
        "        if(p * p > n)",
        "            break;",
        "        int cnt = 0;",
        "        if(n % p == 0) {",
        "            while(n % p == 0) {",
        "                n /= p;",
        "                cnt++;",
        "            }",
        "            pf.push_back(p);",
        "            times.push_back(cnt);",
        "        }",
        "    }",
        "    if(n > 1) {",
        "        pf.push_back(n);",
        "        times.push_back(1);",
        "    }",
        "}"
    ],
    "description": "Description for Primefactor O(n x n)"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "const int lim = $1;",
            "int parent[lim], len[lim];",
            "",
            "void make_set(int n) {",
            "    for(int i = 0; i <= n; i++) {",
            "        parent[i] = i;",
            "        len[i] = 1;",
            "    }",
            "}",
            "",
            "int find_set(int v) {",
            "    if(parent[v] == v)",
            "        return v;",
            "    return parent[v] = find_set(parent[v]);",
            "}",
            "",
            "void union_set(int a, int b) {",
            "    a = find_set(a);",
            "    b = find_set(b);",
            "    if(a != b) {",
            "        if(len[a] < len[b])",
            "            swap(a, b);",
            "        parent[b] = a;",
            "        len[a] += len[b];",
            "    }",
            "}"
        ],
        "description": "Description for DSU"
    },
    "Trie String": {
        "prefix": "trie_string",
        "body": [
            "const int lim = 26;",
            "",
            "struct Trie {",
            "    struct node {",
            "        int cnt, val;",
            "        bool ending;",
            "        node *next[lim];",
            "        node *child[2];",
            "",
            "        node() {",
            "            cnt = 0, val = 0;",
            "            ending = false;",
            "            child[0] = NULL, child[1] = NULL;",
            "            for (int i = 0; i < lim; i++)",
            "                next[i] = NULL;",
            "        }",
            "    } *root;",
            "",
            "    void init() {",
            "        root = new node();",
            "    }",
            "",
            "    void insert_string(string s) {",
            "        node *curr = root;",
            "        for (int i = 0; i < s.size(); i++) {",
            "            int id = s[i] - 'a';",
            "            if (curr->next[id] == NULL)",
            "                curr->next[id] = new node();",
            "            curr = curr->next[id];",
            "        }",
            "        curr->cnt++;",
            "        curr->ending = true;",
            "    }",
            "",
            "    bool search_string(string s) {",
            "        node *curr = root;",
            "        for (int i = 0; i < s.size(); i++) {",
            "            int id = s[i] - 'a';",
            "            if (curr->next[id] == NULL)",
            "                return false;",
            "            curr = curr->next[id];",
            "        }",
            "        return (curr->ending);",
            "    }",
            "",
            "    int word_cnt(string s) {",
            "        node *curr = root;",
            "        for (int i = 0; i < s.size(); i++) {",
            "            int id = s[i] - 'a';",
            "            if (curr->next[id] == NULL)",
            "                return 0;",
            "            curr = curr->next[id];",
            "        }",
            "        return curr->cnt;",
            "    }",
            "};"
        ],
        "description": "Description for Trie String"
    },
    "Trie Number": {
        "prefix": "trie_number",
        "body": [
            "struct Trie",
            "{",
            "    struct node",
            "    {",
            "        int cnt, val;",
            "        bool ending;",
            "        node *child[2];",
            "",
            "        node()",
            "        {",
            "            cnt = 0, val = 0;",
            "            ending = false;",
            "            child[0] = NULL, child[1] = NULL;",
            "        }",
            "    } * root;",
            "",
            "    void init()",
            "    {",
            "        root = new node();",
            "    }",
            "",
            "    void insert_num(int n)",
            "    {",
            "        node *curr = root;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int id = get_bit(n, i);",
            "            if (curr->child[id] == NULL)",
            "                curr->child[id] = new node();",
            "            curr = curr->child[id];",
            "            curr->cnt++;",
            "        }",
            "        curr->val = n;",
            "    }",
            "",
            "    void delete_num(int n)",
            "    {",
            "        node *curr = root;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int id = get_bit(n, i);",
            "            curr = curr->child[id];",
            "            curr->cnt--;",
            "        }",
            "    }",
            "",
            "    bool search_num(int n)",
            "    {",
            "        node *curr = root;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int id = get_bit(n, i);",
            "            if (curr->child[id] == NULL)",
            "                return false;",
            "            curr = curr->child[id];",
            "        }",
            "        return (curr->cnt);",
            "    }",
            "",
            "    int max_array_xor(vector<int> v, int x)",
            "    {",
            "        int ans = 0;",
            "        for (int i = 0; i < v.size(); i++)",
            "        {",
            "            node *curr = root;",
            "            for (int j = 31; j >= 0; j--)",
            "            {",
            "                int id = get_bit(v[i], j);",
            "                if (curr->child[1 - id] != NULL && curr->child[1 - id]->cnt > 0)",
            "                    curr = curr->child[1 - id];",
            "                else if (curr->child[id] != NULL)",
            "                    curr = curr->child[id];",
            "                curr->cnt--;",
            "            }",
            "            int curr_max = (x ^ (curr->val));",
            "            ans = max(ans, curr_max);",
            "        }",
            "        return ans;",
            "    }",
            "",
            "    ll max_value_xor(int n)",
            "    {",
            "        node *curr = root;",
            "        ll ans = 0;",
            "        for (int i = 31; i >= 0; i--)",
            "        {",
            "            int id = get_bit(n, i);",
            "            if (curr->child[1 - id] != NULL && curr->child[1 - id]->cnt > 0)",
            "            {",
            "                curr = curr->child[1 - id];",
            "                set_bit(ans, i);",
            "            }",
            "            else if (curr->child[id] != NULL && curr->child[id]->cnt > 0)",
            "            {",
            "                curr = curr->child[id];",
            "            }",
            "        }",
            "        return ans;",
            "    }",
            "};"
        ]
    },
    "Palindrome": {
        "prefix": "palindrome",
        "body": [
            "bool isPalindrome(string s)",
            "{",
            "    string t = s;",
            "    reverse(all(s));",
            "",
            "    return (s == t);",
            "}"
        ],
        "description": ""
    },
    "Primefactor O(log N)": {
        "prefix": "primefactor",
        "body": [
            "const int lim = 1e7;",
            "",
            "bool prime[lim + 10];",
            "vector <int> pNum;",
            "",
            "int spf[lim + 10];",
            "",
            "void sieve()",
            "{",
            "    spf[1] = 1;",
            "    for (int i = 2; i <= lim; i++)",
            "    {",
            "        spf[i] = i;",
            "    }",
            "",
            "    for (int i = 4; i <= lim; i += 2)",
            "    {",
            "        spf[i] = 2;",
            "    }",
            "",
            "    for (int i = 3; (ll)i * i <= lim; i++)",
            "    {",
            "        if (spf[i] == i)",
            "        {",
            "            for (int j = i * i; j <= lim; j += i)",
            "            {",
            "                if (spf[j] == j)",
            "                    spf[j] = i;",
            "            }",
            "        }",
            "    }",
            "}"
        ],
        "description": ""
    },
    "Equal": {
        "prefix": "equal",
        "body": [
            "bool isEqual(double a, double b)",
            "{",
            "    return abs(a - b) <= eps;",
            "}"
        ],
        "description": ""
    },
    "Greater": {
    "prefix": "greater",
    "body": [
        "bool isGreater(double a, double b)",
        "{",
        "    return a > b + eps;",
        "}"
    ],
    "description": ""
    },
    "Long Division Quotient": {
    "prefix": "long_division_quotient",
    "body": [
        "string long_division(string number, int div)",
        "{",
        "    string ans = \"\";",
        "    int ind = 0;",
        "    int temp = number[ind] - '0';",
        "",
        "    while (temp < div)",
        "    {",
        "        temp = temp * 10 + number[++ind] - '0';",
        "    }",
        "",
        "    while (number.size() > ind)",
        "    {",
        "        ans += temp / div + '0';",
        "        temp = (temp % div) * 10 + number[++ind] - '0';",
        "    }",
        "",
        "    if (ans.size() == 0)",
        "        return \"0\";",
        "    else",
        "        return ans;",
        "}"
    ],
    "description": ""
},
    "Long Division Remainder": {
    "prefix": "long_division_remainder",
    "body": [
        "int long_division(string number, int div)",
        "{",
        "    int ans = 0;",
        "",
        "    for (ll i = 0; i < number.size(); i++)",
        "    {",
        "        ans = (ans * 10 + number[i] - '0') % div;",
        "    }",
        "",
        "    return ans;",
        "}"
    ],
    "description": ""
},
    "NCR": {
    "prefix": "ncr",
    "body": [
        "ll gcd(ll a, ll b)",
        "{",
        "    if (b == 0)",
        "        return a;",
        "    else",
        "        return gcd(b, a % b);",
        "}",
        "",
        "ll ncr(int n, int r)",
        "{",
        "    if (n < r)",
        "        return 0;",
        "",
        "    if (r == 0)",
        "        return 1;",
        "",
        "    ll num = 1, den = 1;",
        "    r = min(r, n - r);",
        "",
        "    while (r > 0)",
        "    {",
        "        num *= n;",
        "        den *= r;",
        "        ll g = gcd(num, den);",
        "        num /= g;",
        "        den /= g;",
        "        n--;",
        "        r--;",
        "    }",
        "",
        "    return num;",
        "}"
    ],
    "description": ""
},
    "Pascal's Triangle": {
    "prefix": "pascals_triangle",
    "body": [
        "const int lim = 60;",
        "ll tri[lim + 5][lim + 5];",
        "",
        "void pascalTriangle()",
        "{",
        "    for (int i = 0; i < lim; i++)",
        "    {",
        "        for (int j = 0; j <= i; j++)",
        "        {",
        "            if (j == 0 || i == j)",
        "                tri[i][j] = 1;",
        "            else",
        "                tri[i][j] = tri[i - 1][j - 1] + tri[i - 1][j];",
        "        }",
        "    }",
        "}"
    ],
    "description": ""
},
    "Point Distance": {
    "prefix": "point_distance",
    "body": [
        "double point_distance(int ax, int ay, int bx, int by)",
        "{",
        "    double a = (ax - bx) * (ax - bx);",
        "    double b = (ay - by) * (ay - by);",
        "    double ans = sqrt(a + b);",
        "",
        "    return ans;",
        "}"
    ],
    "description": ""
},
"Smaller": {
    "prefix": "smaller",
    "body": [
        "bool isSmaller(double a, double b)",
        "{",
        "    return a + eps < b;",
        "}"
    ],
    "description": ""
},
"Decimal to Binary": {
    "prefix": "dec_to_bin",
    "body": [
        "string dec_to_bin(ll n)",
        "{",
        "    string ans = \"\";",
        "    while(n)",
        "    {",
        "        ans += to_string(n % 2);",
        "        n /= 2;",
        "    }",
        "    reverse(all(ans));",
        "",
        "    return ans;",
        "}"
    ],
    "description": ""
},
"Segment Tree": {
    "prefix": "segment_tree",
    "body": [
        "const int lim = 1e5 + 10;",
        "ll num[lim], seg[4 * lim], lazy[4 * lim];",
        "",
        "void build(int i, int lo, int hi)",
        "{",
        "    if (lo == hi)",
        "    {",
        "        seg[i] = num[lo];",
        "        return;",
        "    }",
        "",
        "    int mid = (lo + hi) / 2;",
        "    int left = 2 * i + 1;",
        "    int right = 2 * i + 2;",
        "    ",
        "    build(left, lo, mid);",
        "    build(right, mid + 1, hi);",
        "",
        "    seg[i] = seg[left] + seg[right];",
        "}"
    ],
    "description": "Segment Tree"
},
"Split String": {
    "prefix": "split_string",
    "body": [
        "void split_string(string s, char delimiter)",
        "{",
        "    string b;",
        "    stringstream a(s);",
        "    ",
        "    while(getline(a, b, delimiter))",
        "    {",
        "        cout << b << en;",
        "    }",
        "}"
    ],
    "description": "Split String"
},
"pbds": {
    "prefix": "pbds",
    "body": [
        "#include <ext/pb_ds/assoc_container.hpp>",
        "#include <ext/pb_ds/tree_policy.hpp>",
        "using namespace __gnu_pbds;",
        "",
        "typedef tree<",
        "    int, // the data type",
        "    null_type, // null_type for the set",
        "    less<int>, // the comparator. less_equal : ascending multimap, greater : descending",
        "    rb_tree_tag, // the tree structure would be red black tree",
        "    tree_order_statistics_node_update",
        "> ordered_set;"
    ],
    "description": "Policy-Based Data Structure (PBDS)"
},
"Decimal to Hexa": {
    "prefix": "dec_to_hex",
    "body": [
        "string dec_to_hex(ll n)",
        "{",
        "    stringstream ss;",
        "    ss << hex << n;",
        "    string ans(ss.str());",
        "    return ans;",
        "}"
    ],
    "description": "Decimal to Hexadecimal Conversion"
},
"MST-Kruskal": {
    "prefix": "kruskal",
    "body": [
        "const int lim = ",
        "int parent[lim], len[lim];",
        "",
        "struct Edge",
        "{",
        "    int u, v, w;",
        "",
        "    Edge(int u, int v, int w) : u(u), v(v), w(w) {}",
        "    bool operator < (const Edge &q) const ",
        "    {",
        "        return w < q.w;",
        "    }",
        "};",
        "",
        "vector <Edge> edge;",
        "vector<pair<int, int>> graph[lim];",
        "",
        "void make_set(int n)",
        "{",
        "    edge.clear();",
        "    for(int i = 0; i <= n; i++)",
        "    {",
        "        parent[i] = i;",
        "        len[i] = 1;",
        "    }",
        "}",
        "",
        "int find_set(int v)",
        "{",
        "    if(parent[v] == v)",
        "        return v;",
        "",
        "    return parent[v] = find_set(parent[v]);",
        "}",
        "",
        "void union_set(int a, int b)",
        "{",
        "    a = find_set(a);",
        "    b = find_set(b);",
        "",
        "    if(a != b)",
        "    {",
        "        if(len[a] < len[b])",
        "            swap(a, b);",
        "",
        "        parent[b] = a;",
        "        len[a] += len[b];",
        "    }",
        "}",
        "",
        "ll kruskal()",
        "{",
        "    sort(edge.begin(), edge.end());",
        "    ll ans = 0;",
        "",
        "    for(auto x : edge)",
        "    {",
        "        int u = x.u, v = x.v, w = x.w;",
        "        ",
        "        if(find_set(u) != find_set(v))",
        "        {",
        "            ans += w;",
        "            union_set(u, v);",
        "            graph[u].push_back({v, w});",
        "            graph[v].push_back({u, w});",
        "        }",
        "    }",
        "",
        "    return ans;",
        "}"
    ],
    "description": "Minimum Spanning Tree (Kruskal's Algorithm)"
},
"Euler's Totient": {
    "prefix": "totient",
    "body": [
        "const int lim = ",
        "int phi[lim];",
        "",
        "void eulers_totient() ",
        "{",
        "    phi[0] = 0;",
        "    phi[1] = 1;",
        "    for (int i = 2; i < lim; i++)",
        "        phi[i] = i - 1;",
        "",
        "    for (int i = 2; i < lim; i++)",
        "        for (int j = 2 * i; j < lim; j += i)",
        "              phi[j] -= phi[i];",
        "}"
    ],
    "description": "Euler's Totient"
},
"LCA using binary lifting": {
    "prefix": "lca",
    "body": [
        "const int lim = 2e5 + 10, level = 19;",
        "vector <int> graph[lim];",
        "int parent[lim][level + 10], depth[lim], n, m;",
        "",
        "void dfs(int node, int par)",
        "{",
        "    parent[node][0] = par;",
        "    depth[node] = depth[par] + 1;",
        "",
        "    for(int i = 0; i < graph[node].size(); i++)",
        "    {",
        "        int c = graph[node][i];",
        "        if(c != par)",
        "            dfs(c, node);",
        "    }",
        "}",
        "",
        "void binary_lifting()",
        "{",
        "    for(int i = 1; i < level; i++)",
        "    {",
        "        for(int node = 1; node <= n; node++)",
        "        {",
        "            if(parent[ node ][ i - 1 ] != -1)",
        "                parent[node][i] = parent[ parent[node][i - 1] ][i - 1];",
        "        }",
        "    }",
        "}",
        "",
        "int lca(int u, int v)",
        "{",
        "    if(depth[v] < depth[u])",
        "        swap(u, v);",
        "",
        "    int k = depth[v] - depth[u];",
        "    for(int i = level; i >= 0; i--)",
        "    {",
        "        if(k & (1 << i))",
        "            v = parent[v][i];",
        "    }",
        "    if(u == v)",
        "        return u;",
        "",
        "    for(int i = level; i >= 0; i--)",
        "    {",
        "        if(parent[u][i] != parent[v][i])",
        "        {",
        "            u = parent[u][i];",
        "            v = parent[v][i];",
        "        }",
        "    }",
        "    return parent[u][0];",
        "}"
    ],
    "description": "LCA using binary lifting"
    }
}
